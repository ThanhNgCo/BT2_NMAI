// CẤU HÌNH BẢN ĐỒ 10x8
const COLS = 10;
const ROWS = 8;
const CELL_SIZE = 60; // Kích thước ô lớn cho giống ảnh demo
let grid = [];
let openSet = [];
let closedSet = [];
let path = [];
let startNode;
let endNode;
let isRunning = false;
let isFinished = false;

// Tọa độ S và G cố định theo đề bài
// S(3,0), G(3,9) (Lưu ý: x là cột, y là hàng)
const START_POS = { x: 0, y: 3 }; 
const END_POS = { x: 9, y: 3 };

function setup() {
    // Tạo canvas và gắn vào div bên phải
    let canvas = createCanvas(COLS * CELL_SIZE + 1, ROWS * CELL_SIZE + 1);
    canvas.parent('sketch-holder');
    
    resetMap(); // Khởi tạo bản đồ
}

function draw() {
    background(255);
    
    // 1. Vẽ lưới và các ô
    for (let i = 0; i < COLS; i++) {
        for (let j = 0; j < ROWS; j++) {
            grid[i][j].show();
        }
    }

    // 2. Chạy thuật toán A* (Animation) mỗi frame
    if (isRunning && !isFinished) {
        // Chạy chậm lại chút để quan sát (nếu muốn nhanh xóa vòng lặp này)
        // A* Step logic
        if (openSet.length > 0) {
            // Tìm node có f thấp nhất
            let lowestIndex = 0;
            for (let i = 0; i < openSet.length; i++) {
                if (openSet[i].f < openSet[lowestIndex].f) {
                    lowestIndex = i;
                }
            }
            let current = openSet[lowestIndex];

            // Nếu đã đến đích
            if (current === endNode) {
                noLoop();
                console.log("DONE!");
                isRunning = false;
                isFinished = true;
                document.getElementById('mode').innerText = "Đã tìm thấy đường!";
                calculatePath(current);
                return;
            }

            // Chuyển từ Open -> Closed
            openSet.splice(lowestIndex, 1);
            closedSet.push(current);

            // Duyệt lân cận
            let neighbors = current.neighbors;
            for (let i = 0; i < neighbors.length; i++) {
                let neighbor = neighbors[i];

                // Nếu không phải tường và chưa nằm trong Closed Set
                if (!closedSet.includes(neighbor) && !neighbor.wall) {
                    let tempG = current.g + 1; // Khoảng cách = 1

                    let newPath = false;
                    if (openSet.includes(neighbor)) {
                        if (tempG < neighbor.g) {
                            neighbor.g = tempG;
                            newPath = true;
                        }
                    } else {
                        neighbor.g = tempG;
                        newPath = true;
                        openSet.push(neighbor);
                    }

                    if (newPath) {
                        neighbor.h = heuristic(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = current;
                    }
                }
            }
            
            // Cập nhật thông số hiển thị HTML
            document.getElementById('considered').innerText = closedSet.length;

        } else {
            // Không tìm thấy đường
            console.log("NO SOLUTION");
            isRunning = false;
            isFinished = true;
            document.getElementById('mode').innerText = "Không tìm thấy đường đi!";
            noLoop();
            return;
        }
    }

    // 3. Vẽ đường đi (Path) nếu đang chạy hoặc đã xong
    // Vẽ đường tạm thời từ current node về start
    if (!isFinished && openSet.length > 0) {
         // Tìm node tốt nhất hiện tại để vẽ path tạm
        let lowestIndex = 0;
        for (let i = 0; i < openSet.length; i++) {
            if (openSet[i].f < openSet[lowestIndex].f) lowestIndex = i;
        }
        calculatePath(openSet[lowestIndex]);
    }
    
    // Vẽ đường path màu đỏ
    noFill();
    stroke(255, 0, 0);
    strokeWeight(4);
    beginShape();
    for (let i = 0; i < path.length; i++) {
        vertex(path[i].i * CELL_SIZE + CELL_SIZE / 2, path[i].j * CELL_SIZE + CELL_SIZE / 2);
    }
    endShape();
}

// --- CLASS NODE (Ô) ---
function Spot(i, j) {
    this.i = i; // Cột (x)
    this.j = j; // Hàng (y)
    this.f = 0;
    this.g = 0;
    this.h = 0;
    this.neighbors = [];
    this.parent = undefined;
    this.wall = false;

    // Hàm hiển thị ô
    this.show = function() {
        stroke(0);
        strokeWeight(1);
        
        // Màu mặc định: Trắng
        fill(255);
        
        // Nếu là tường: Đen
        if (this.wall) fill(50);
        
        // Đã duyệt (Closed): Màu vàng nhạt (giống demo cũ)
        if (closedSet.includes(this)) fill(255, 255, 150);
        
        // Đang xét (Open): Màu xanh lá mạ
        if (openSet.includes(this)) fill(150, 255, 150);
        
        // Start: Xanh lá đậm, Goal: Xanh dương đậm
        if (this === startNode) fill(0, 255, 0); 
        if (this === endNode) fill(0, 0, 255);

        rect(this.i * CELL_SIZE, this.j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        
        // Vẽ chữ S và G
        if (this === startNode) {
            fill(0); noStroke(); textAlign(CENTER, CENTER); textSize(24); textStyle(BOLD);
            text("S", this.i * CELL_SIZE + CELL_SIZE/2, this.j * CELL_SIZE + CELL_SIZE/2);
        }
        if (this === endNode) {
            fill(255); noStroke(); textAlign(CENTER, CENTER); textSize(24); textStyle(BOLD);
            text("G", this.i * CELL_SIZE + CELL_SIZE/2, this.j * CELL_SIZE + CELL_SIZE/2);
        }
    }

    this.addNeighbors = function(grid) {
        let i = this.i;
        let j = this.j;
        // Chỉ đi 4 hướng (Trên, Dưới, Trái, Phải)
        if (i < COLS - 1) this.neighbors.push(grid[i + 1][j]);
        if (i > 0)        this.neighbors.push(grid[i - 1][j]);
        if (j < ROWS - 1) this.neighbors.push(grid[i][j + 1]);
        if (j > 0)        this.neighbors.push(grid[i][j - 1]);
    }
}

// --- HÀM HỖ TRỢ ---

function heuristic(a, b) {
    // Manhattan distance
    return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
}

function calculatePath(current) {
    path = [];
    let temp = current;
    path.push(temp);
    while (temp.parent) {
        path.push(temp.parent);
        temp = temp.parent;
    }
    // Cập nhật kết quả ra HTML
    if (isFinished) {
        document.getElementById('path-len').innerText = path.length;
        document.getElementById('cost').innerText = path.length - 1; // Chi phí trừ nút start
    }
}

// --- HÀM KHỞI TẠO & SỰ KIỆN ---

function resetMap() {
    // Reset biến
    grid = [];
    openSet = [];
    closedSet = [];
    path = [];
    isRunning = false;
    isFinished = false;
    document.getElementById('mode').innerText = "Sẵn sàng";
    document.getElementById('path-len').innerText = "0";
    document.getElementById('cost').innerText = "0";
    document.getElementById('considered').innerText = "0";

    // Tạo lưới
    for (let i = 0; i < COLS; i++) {
        grid[i] = [];
        for (let j = 0; j < ROWS; j++) {
            grid[i][j] = new Spot(i, j);
        }
    }

    // Thêm lân cận
    for (let i = 0; i < COLS; i++) {
        for (let j = 0; j < ROWS; j++) {
            grid[i][j].addNeighbors(grid);
        }
    }

    // Gán Start và Goal
    startNode = grid[START_POS.x][START_POS.y];
    endNode = grid[END_POS.x][END_POS.y];

    // --- TẠO VẬT CẢN (Hardcode theo hình đề bài) ---
    // Lưu ý: grid[col][row] tương ứng (x, y)
    
    // Khối trên cùng (Hàng 1, cột 1-5) -> y=1, x=1->5
    for(let x=1; x<=5; x++) grid[x][1].wall = true;
    
    // Khối nối trên (Hàng 2, cột 4-7) -> y=2, x=4->7
    for(let x=4; x<=7; x++) grid[x][2].wall = true;
    
    // Khối chặn giữa (Hàng 3, cột 7) -> y=3, x=7
    grid[7][3].wall = true;
    
    // Khối nối dưới (Hàng 4, cột 4-7) -> y=4, x=4->7
    for(let x=4; x<=7; x++) grid[x][4].wall = true;
    
    // Khối dưới cùng (Hàng 5, cột 1-5) -> y=5, x=1->5
    for(let x=1; x<=5; x++) grid[x][5].wall = true;

    // Đảm bảo S và G không phải tường
    startNode.wall = false;
    endNode.wall = false;
    
    openSet.push(startNode);
    loop(); // Vẽ lại
}

function runAStar() {
    if (isFinished) resetMap(); // Reset nếu đã chạy xong
    isRunning = true;
    document.getElementById('mode').innerText = "Đang chạy...";
    loop();
}
